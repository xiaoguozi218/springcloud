
作为服务注册中心，Eureka比Zookeeper好在哪里？
    著名的CAP理论指出，一个分布式系统不可能同时满足CAP. 由于分区容错性P是分布式系统必须要保证的， 因此我们只能在A和C之间进行权衡。


4.1 Zookeeper保证CP
    当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求高于一致性。
但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30~120s，且选举期间整个
zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络环境使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举
时间导致的注册长期不可用是不能容忍的。

4.2 Eureka保证AP
    Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常工作，剩余的节点依然可以提供注册和查询服务。而Eureka
 的客户端在向某个Eureka注册时如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）。
 除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
    1、Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
    2、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上（既保证当前节点依然可用）
    3、当网络稳定时，当前实例的注册信息会被同步到其它节点中。

 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个注册服务瘫痪。





六、Spring Cloud Ribbon 是基于Netflix Ribbon实现的一套客户端（Consumer） 负载均衡的工具。

    简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组建提供一系列完善的配置项如连接超时，重试等。
 简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动地帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义
 的负载均衡算法。

LB,即负载均衡（Load Balance），在微服务分布式集群中经常用到的一种应用。
负载均衡简单的说就是将用户的请求平均的分配到多个服务上，从而达到系统的HA.
常见的负载均衡软件有： Nginx、LVS、硬件F5 等。
相应的中间件，例如：dubbo和Spring Cloud中均给我们提供了负载均衡，  Spring Cloud的负载均衡算法可以自定义。

    LB: 1、集中式LB   即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx）,由该设施负责把访问请求通过某种策略转发至服务的提供方；
        2、进程式LB   将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。
                       Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。


Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号。

Ribbon在工作时分成两步：
    第一步先选择EurekaServer，它优先选择在同一个区域内负载较少的server。
    第二步再根据用户指定的策略，再从server取到的服务注册列表中选择一个地址。
   其中Ribbon提供了多种策略：比如 轮询、随机和根据响应时间加权。

总结： Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。

Ribbon核心组件IRule
    IRule : 根据特定算法中从服务列表中选取一个要访问的服务








十一、第一季总结/第二及展望

    阶段1：单机集中构建网站
    阶段2：应用服务器配置集群
    阶段3：nginx+应用服务器配置集群+HA
    阶段4：CDN+Varnish服务器配置集群
    阶段5：数据库读写分离
    阶段6：NoSql + 分布式搜索引擎
    阶段7：NoSql(HA) + 分库分表 + MyCat
    阶段8：分布式文件系统
    阶段9：应用服务化拆分+消息中间件
    阶段10：微服务架构